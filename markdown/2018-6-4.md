2018/6/4 21:32:16 
                
<div><span style="font-size:32px;">互斥锁：</span></div>
<div><span style="font-size:18px;">1、互斥锁基本原理：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;互斥锁是一个二元变量，其状态为开锁(允许0)和上锁(禁止1)，将某个共享资源与某个特定互斥锁在逻辑上绑定(要申请该资源必须先获取锁)。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;(1)访问公共资源前，必须申请该互斥锁，若处于开锁状态，则申请到锁对象，并立即占有该锁，以防止其他线程访问该资源；如果该互斥锁处于锁定状态，则阻塞当前线程。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;(2)只有锁定该互斥锁的进程才能释放该互斥锁，其他线程试图释放无效。</span></div>
<div><span style="font-size:18px;">2、初始化互斥锁：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;使用之前，需要定义互斥锁，使用函数：pthread_mutex_t lock;进行定义。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;初始化锁：</span></div>
<div><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern int &nbsp;&nbsp; pthread_mutex_init(pthread_mutex_t *_mutex,_const pthread_mutex_mutexattr_t* _mutexattr)</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第一个参数mutex指要初始化的互斥锁的指针。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第二个参数mutexattr是指向对象的指针，如果该属性为空，则使用默认的属性。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 全用宏PTHREAD_MUTEX_INITIALIZER来初始化静态分配的互斥锁(全局锁)；</span></div>
<div><span style="font-size:18px;">3、申请互斥锁</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;如果一个线程要占用共享资源，必须先申请对应互斥锁，使用函数：</span></div>
<div><span style="font-size:18px;"><span style="white-space:pre;"></span>extern int pthread_mutex_lock(pthread_mutex* _mutex)以阻塞方式申请互斥锁；</span></div>
<div><span style="font-size:18px;"><span style="white-space:pre;"></span>extern int pthread_mutex_trylock(pthread_mutex* _mutex)以非阻塞方式申请互斥锁；</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; 若申请成功，返回0，否则，返回一个错误编号。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;&lt;注：参数都是要申请互斥锁的指针&gt;</span></div>
<div><span style="font-size:18px;">4、释放互斥锁</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;释放互斥锁用函数：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;extern int pthread_mutex_unlock(pthread_mutex_t* _mutex)</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;参数mutex是指向要解锁的互斥锁的指针</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;释放只能由占有该互斥锁的线程完成，如果释放成功，返回0，失败返回错误编号。</span></div>
<div align="left" style="min-height:16pt;"><span style="font-size:18px;"><span style="font-family:ArialMT;color:#010101;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock</span><span style="font-family:'AdobeSongStd-Light';color:#010101;">中的释放锁操作同样只用一条指令实现，以保证它的原子性。</span></span></div>
<div><span style="font-size:18px;">5、例：如下代码：</span></div>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 237px; top: 1152px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 237px; top: 1152px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#include&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;pthread.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;string.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;sys/types.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;unistd.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>*&nbsp;pthread_run()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;5000)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"process&nbsp;ID:%d,pthread&nbsp;ID:%lu,count:%d\n"</span><span>,getpid(),pthread_self(),count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;ret&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id2;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id1,NULL);&nbsp;&nbsp;<span class="comment">//wait</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id2,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"count:&nbsp;%d\n"</span><span>,count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
int count = 0;

void* pthread_run()
{
    int i = 0;
    int ret = 0;
    while(i &lt; 5000)
    {
        i++;
        ret = count;
        printf("process ID:%d,pthread ID:%lu,count:%d\n",getpid(),pthread_self(),count);
        count = ret + 1;
    }
}

int main()
{
    int ret = 0;
    pthread_t id1;
    pthread_t id2;
    pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);
    pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);
    pthread_join(id1,NULL);  //wait
    pthread_join(id2,NULL);
    printf("count: %d\n",count);
    return 0;
}</pre>
<p><br></p>
<p><img src="https://img-blog.csdn.net/20170605124437896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1JOR1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
<p><br></p>
<p></p>
<div><span style="font-size:18px;">原本count全局变量+1，加5000次，但是两个线程理应加到10000才正确，但是因为count不是原子性，导致出错；</span></div>
<div style="margin:0px 0px 1.1em;">
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">我们要清楚一个增量操作分为三步骤：&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">1)从内存当中读入寄存器&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">2)寄存器进行增量操作&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">3)写回内存</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">正因为这三步操作，所以当不同步的时候，第一个线程已经对增量操作了，但是第二个线程读取到的依然是第一个线程增量操作之前的内容。这样就会出现问题，本来应该由1增加到3的，结果变为了由1到2。</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">要想代码按照我们预期的想法加到10000，必须加互斥锁，保护临界资源：修改上代码如下：</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"></span></span><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 237px; top: 2264px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 237px; top: 2264px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#include&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;pthread.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;string.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;sys/types.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;unistd.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>pthread_mutex_t&nbsp;lock&nbsp;=&nbsp;PTHREAD_MUTEX_INITIALIZER;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>*&nbsp;pthread_run()&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;5000)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;lock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"process&nbsp;ID:%d,pthread&nbsp;ID:%lu,count:%d\n"</span><span>,getpid(),pthread_self(),count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;ret&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;lock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;sleep(200);</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//return&nbsp;(void*)5;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id1,NULL);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id2,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"count:&nbsp;%d\n"</span><span>,count);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
int count = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* pthread_run()
{
    int i = 0;
    int ret = 0;
    while(i &lt; 5000)
    {
        pthread_mutex_lock(&amp;lock);
        i++;
        ret = count;
        printf("process ID:%d,pthread ID:%lu,count:%d\n",getpid(),pthread_self(),count);
        count = ret + 1;
        pthread_mutex_unlock(&amp;lock);
    }
    // sleep(200);
    //return (void*)5;
}

int main()
{
    int ret = 0;
    pthread_t id1;
    pthread_t id2;
    pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);
    pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);
    pthread_join(id1,NULL);  
    pthread_join(id2,NULL);
    printf("count: %d\n",count);
    return 0;
}
</pre>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-family:'microsoft yahei';"><span style="color:rgb(51,51,51);">添加互斥锁保证其原子性，结果正确：</span></span><br></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><br></span></span></div>
<img src="https://img-blog.csdn.net/20170605134804311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1JOR1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"></span></span>
<div style="margin:0px 0px 1.1em;">
<div><span style="font-size:32px;">死锁：</span></div>
<div>1、什么是死锁：</div>
<div align="left" style="min-height:16pt;">
<div><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，如果同一个线程先后两次调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，在第二次调用时，由于锁已经被占用，该线程会</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">就永远处于挂起等待状态了，这叫做死锁（</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">Deadlock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">）。</span></span></div>
<div><span style="font-size:12pt;"><span style="font-family:'AdobeSongStd-Light';"><span style="color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;另一种：若</span></span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">获</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">得了锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">获得了锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，这时线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">试图获得锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，结果是需要挂起等待线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">释放</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，而这时线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">也调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">试图获得锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，结果是需要挂起等待线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">释放锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，于是线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">和</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">都</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">永远处于挂起状态了。</span></span></div>
</div>
<div><span style="font-size:18px;">2、死锁产生的四个必要条件：</span></div>
<div><span style="color:rgb(111,111,111);font-family:Arial;"><span style="font-size:18px;">（1）&nbsp;互斥条件：一个资源每次只能被一个进程使用</span></span></div>
<div><span style="font-size:18px;"><span style="color:rgb(111,111,111);font-family:Arial;">（2）&nbsp;请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br style="color:rgb(111,111,111);font-family:Arial;"><span style="color:rgb(111,111,111);font-family:Arial;">（3）&nbsp;不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br style="color:rgb(111,111,111);font-family:Arial;"><span style="color:rgb(111,111,111);font-family:Arial;">（4）&nbsp;循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></span></div>
<div><span style="font-size:18px;"><span style="color:rgb(111,111,111);font-family:Arial;">这四个条件是</span><span style="font-family:Arial;background-color:rgb(255,255,102);">死锁的必要条件</span><span style="color:rgb(111,111,111);font-family:Arial;">，只要系统发生死锁，这些条件必然成立，而只要上述条件之</span><span style="color:rgb(111,111,111);font-family:Arial;">一不满足，就不会发生死锁。</span></span></div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;">3、如何避免死锁：</span></span></span></div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;"><br></span></span></span></div>
<div>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">预防死锁：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">资源一次性分配：（破坏请求和保持条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">避免死锁:</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库" style="color:rgb(223,52,52);font-weight:bold;" target="_blank">算法</a>是银行家算法。</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">检测死锁</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">首先为每个进程和每个资源指定一个唯一的号码；</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">然后建立资源分配表和进程等待表，例如：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">解除死锁:</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</span></p>
<div style="margin:0px 0px 1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</span></div>
</div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></span></span></span></div>
<div><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div><span style="font-size:32px;"><br></span></div>
</div>
<br></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><br></span></span></div>
</div>
<br><p></p>
            </div>
                </div>
			</article>
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css">
            <div class="htmledit_views">
                
<div><span style="font-size:32px;">互斥锁：</span></div>
<div><span style="font-size:18px;">1、互斥锁基本原理：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;互斥锁是一个二元变量，其状态为开锁(允许0)和上锁(禁止1)，将某个共享资源与某个特定互斥锁在逻辑上绑定(要申请该资源必须先获取锁)。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;(1)访问公共资源前，必须申请该互斥锁，若处于开锁状态，则申请到锁对象，并立即占有该锁，以防止其他线程访问该资源；如果该互斥锁处于锁定状态，则阻塞当前线程。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;(2)只有锁定该互斥锁的进程才能释放该互斥锁，其他线程试图释放无效。</span></div>
<div><span style="font-size:18px;">2、初始化互斥锁：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;使用之前，需要定义互斥锁，使用函数：pthread_mutex_t lock;进行定义。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;初始化锁：</span></div>
<div><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern int &nbsp;&nbsp; pthread_mutex_init(pthread_mutex_t *_mutex,_const pthread_mutex_mutexattr_t* _mutexattr)</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第一个参数mutex指要初始化的互斥锁的指针。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第二个参数mutexattr是指向对象的指针，如果该属性为空，则使用默认的属性。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 全用宏PTHREAD_MUTEX_INITIALIZER来初始化静态分配的互斥锁(全局锁)；</span></div>
<div><span style="font-size:18px;">3、申请互斥锁</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;如果一个线程要占用共享资源，必须先申请对应互斥锁，使用函数：</span></div>
<div><span style="font-size:18px;"><span style="white-space:pre;"></span>extern int pthread_mutex_lock(pthread_mutex* _mutex)以阻塞方式申请互斥锁；</span></div>
<div><span style="font-size:18px;"><span style="white-space:pre;"></span>extern int pthread_mutex_trylock(pthread_mutex* _mutex)以非阻塞方式申请互斥锁；</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; 若申请成功，返回0，否则，返回一个错误编号。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;&lt;注：参数都是要申请互斥锁的指针&gt;</span></div>
<div><span style="font-size:18px;">4、释放互斥锁</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;释放互斥锁用函数：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;extern int pthread_mutex_unlock(pthread_mutex_t* _mutex)</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;参数mutex是指向要解锁的互斥锁的指针</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;释放只能由占有该互斥锁的线程完成，如果释放成功，返回0，失败返回错误编号。</span></div>
<div align="left" style="min-height:16pt;"><span style="font-size:18px;"><span style="font-family:ArialMT;color:#010101;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock</span><span style="font-family:'AdobeSongStd-Light';color:#010101;">中的释放锁操作同样只用一条指令实现，以保证它的原子性。</span></span></div>
<div><span style="font-size:18px;">5、例：如下代码：</span></div>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 237px; top: 1152px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 237px; top: 1152px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#include&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;pthread.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;string.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;sys/types.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;unistd.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>*&nbsp;pthread_run()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;5000)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"process&nbsp;ID:%d,pthread&nbsp;ID:%lu,count:%d\n"</span><span>,getpid(),pthread_self(),count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;ret&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id2;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id1,NULL);&nbsp;&nbsp;<span class="comment">//wait</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id2,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"count:&nbsp;%d\n"</span><span>,count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
int count = 0;

void* pthread_run()
{
    int i = 0;
    int ret = 0;
    while(i &lt; 5000)
    {
        i++;
        ret = count;
        printf("process ID:%d,pthread ID:%lu,count:%d\n",getpid(),pthread_self(),count);
        count = ret + 1;
    }
}

int main()
{
    int ret = 0;
    pthread_t id1;
    pthread_t id2;
    pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);
    pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);
    pthread_join(id1,NULL);  //wait
    pthread_join(id2,NULL);
    printf("count: %d\n",count);
    return 0;
}</pre>
<p><br></p>
<p><img src="https://img-blog.csdn.net/20170605124437896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1JOR1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
<p><br></p>
<p></p>
<div><span style="font-size:18px;">原本count全局变量+1，加5000次，但是两个线程理应加到10000才正确，但是因为count不是原子性，导致出错；</span></div>
<div style="margin:0px 0px 1.1em;">
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">我们要清楚一个增量操作分为三步骤：&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">1)从内存当中读入寄存器&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">2)寄存器进行增量操作&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">3)写回内存</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">正因为这三步操作，所以当不同步的时候，第一个线程已经对增量操作了，但是第二个线程读取到的依然是第一个线程增量操作之前的内容。这样就会出现问题，本来应该由1增加到3的，结果变为了由1到2。</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">要想代码按照我们预期的想法加到10000，必须加互斥锁，保护临界资源：修改上代码如下：</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"></span></span><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 237px; top: 2264px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 237px; top: 2264px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#include&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;pthread.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;string.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;sys/types.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;unistd.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>pthread_mutex_t&nbsp;lock&nbsp;=&nbsp;PTHREAD_MUTEX_INITIALIZER;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>*&nbsp;pthread_run()&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;5000)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;lock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"process&nbsp;ID:%d,pthread&nbsp;ID:%lu,count:%d\n"</span><span>,getpid(),pthread_self(),count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;ret&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;lock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;sleep(200);</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//return&nbsp;(void*)5;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id1,NULL);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id2,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"count:&nbsp;%d\n"</span><span>,count);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
int count = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* pthread_run()
{
    int i = 0;
    int ret = 0;
    while(i &lt; 5000)
    {
        pthread_mutex_lock(&amp;lock);
        i++;
        ret = count;
        printf("process ID:%d,pthread ID:%lu,count:%d\n",getpid(),pthread_self(),count);
        count = ret + 1;
        pthread_mutex_unlock(&amp;lock);
    }
    // sleep(200);
    //return (void*)5;
}

int main()
{
    int ret = 0;
    pthread_t id1;
    pthread_t id2;
    pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);
    pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);
    pthread_join(id1,NULL);  
    pthread_join(id2,NULL);
    printf("count: %d\n",count);
    return 0;
}
</pre>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-family:'microsoft yahei';"><span style="color:rgb(51,51,51);">添加互斥锁保证其原子性，结果正确：</span></span><br></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><br></span></span></div>
<img src="https://img-blog.csdn.net/20170605134804311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1JOR1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"></span></span>
<div style="margin:0px 0px 1.1em;">
<div><span style="font-size:32px;">死锁：</span></div>
<div>1、什么是死锁：</div>
<div align="left" style="min-height:16pt;">
<div><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，如果同一个线程先后两次调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，在第二次调用时，由于锁已经被占用，该线程会</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">就永远处于挂起等待状态了，这叫做死锁（</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">Deadlock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">）。</span></span></div>
<div><span style="font-size:12pt;"><span style="font-family:'AdobeSongStd-Light';"><span style="color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;另一种：若</span></span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">获</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">得了锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">获得了锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，这时线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">试图获得锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，结果是需要挂起等待线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">释放</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，而这时线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">也调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">试图获得锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，结果是需要挂起等待线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">释放锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，于是线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">和</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">都</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">永远处于挂起状态了。</span></span></div>
</div>
<div><span style="font-size:18px;">2、死锁产生的四个必要条件：</span></div>
<div><span style="color:rgb(111,111,111);font-family:Arial;"><span style="font-size:18px;">（1）&nbsp;互斥条件：一个资源每次只能被一个进程使用</span></span></div>
<div><span style="font-size:18px;"><span style="color:rgb(111,111,111);font-family:Arial;">（2）&nbsp;请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br style="color:rgb(111,111,111);font-family:Arial;"><span style="color:rgb(111,111,111);font-family:Arial;">（3）&nbsp;不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br style="color:rgb(111,111,111);font-family:Arial;"><span style="color:rgb(111,111,111);font-family:Arial;">（4）&nbsp;循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></span></div>
<div><span style="font-size:18px;"><span style="color:rgb(111,111,111);font-family:Arial;">这四个条件是</span><span style="font-family:Arial;background-color:rgb(255,255,102);">死锁的必要条件</span><span style="color:rgb(111,111,111);font-family:Arial;">，只要系统发生死锁，这些条件必然成立，而只要上述条件之</span><span style="color:rgb(111,111,111);font-family:Arial;">一不满足，就不会发生死锁。</span></span></div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;">3、如何避免死锁：</span></span></span></div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;"><br></span></span></span></div>
<div>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">预防死锁：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">资源一次性分配：（破坏请求和保持条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">避免死锁:</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库" style="color:rgb(223,52,52);font-weight:bold;" target="_blank">算法</a>是银行家算法。</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">检测死锁</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">首先为每个进程和每个资源指定一个唯一的号码；</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">然后建立资源分配表和进程等待表，例如：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">解除死锁:</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</span></p>
<div style="margin:0px 0px 1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</span></div>
</div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></span></span></span></div>
<div><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div><span style="font-size:32px;"><br></span></div>
</div>
<br></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><br></span></span></div>
</div>
<br><p></p>
            </div>
                </div>
                <article>
		<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css">
            <div class="htmledit_views">
                
<div><span style="font-size:32px;">互斥锁：</span></div>
<div><span style="font-size:18px;">1、互斥锁基本原理：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;互斥锁是一个二元变量，其状态为开锁(允许0)和上锁(禁止1)，将某个共享资源与某个特定互斥锁在逻辑上绑定(要申请该资源必须先获取锁)。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;(1)访问公共资源前，必须申请该互斥锁，若处于开锁状态，则申请到锁对象，并立即占有该锁，以防止其他线程访问该资源；如果该互斥锁处于锁定状态，则阻塞当前线程。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;(2)只有锁定该互斥锁的进程才能释放该互斥锁，其他线程试图释放无效。</span></div>
<div><span style="font-size:18px;">2、初始化互斥锁：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;使用之前，需要定义互斥锁，使用函数：pthread_mutex_t lock;进行定义。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;初始化锁：</span></div>
<div><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern int &nbsp;&nbsp; pthread_mutex_init(pthread_mutex_t *_mutex,_const pthread_mutex_mutexattr_t* _mutexattr)</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第一个参数mutex指要初始化的互斥锁的指针。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第二个参数mutexattr是指向对象的指针，如果该属性为空，则使用默认的属性。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 全用宏PTHREAD_MUTEX_INITIALIZER来初始化静态分配的互斥锁(全局锁)；</span></div>
<div><span style="font-size:18px;">3、申请互斥锁</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;如果一个线程要占用共享资源，必须先申请对应互斥锁，使用函数：</span></div>
<div><span style="font-size:18px;"><span style="white-space:pre;"></span>extern int pthread_mutex_lock(pthread_mutex* _mutex)以阻塞方式申请互斥锁；</span></div>
<div><span style="font-size:18px;"><span style="white-space:pre;"></span>extern int pthread_mutex_trylock(pthread_mutex* _mutex)以非阻塞方式申请互斥锁；</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; 若申请成功，返回0，否则，返回一个错误编号。</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;&lt;注：参数都是要申请互斥锁的指针&gt;</span></div>
<div><span style="font-size:18px;">4、释放互斥锁</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;释放互斥锁用函数：</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;extern int pthread_mutex_unlock(pthread_mutex_t* _mutex)</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;参数mutex是指向要解锁的互斥锁的指针</span></div>
<div><span style="font-size:18px;">&nbsp; &nbsp; &nbsp;释放只能由占有该互斥锁的线程完成，如果释放成功，返回0，失败返回错误编号。</span></div>
<div align="left" style="min-height:16pt;"><span style="font-size:18px;"><span style="font-family:ArialMT;color:#010101;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock</span><span style="font-family:'AdobeSongStd-Light';color:#010101;">中的释放锁操作同样只用一条指令实现，以保证它的原子性。</span></span></div>
<div><span style="font-size:18px;">5、例：如下代码：</span></div>
<div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 237px; top: 1152px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 237px; top: 1152px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#include&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;pthread.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;string.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;sys/types.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;unistd.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">void</span><span>*&nbsp;pthread_run()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;5000)&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"process&nbsp;ID:%d,pthread&nbsp;ID:%lu,count:%d\n"</span><span>,getpid(),pthread_self(),count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;ret&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id2;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id1,NULL);&nbsp;&nbsp;<span class="comment">//wait</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id2,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"count:&nbsp;%d\n"</span><span>,count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">#include&lt;stdio.h&gt;
>#include&lt;pthread.h&gt;
>#include&lt;string.h&gt;
>#include&lt;sys/types.h&gt;
>#include&lt;unistd.h&gt;
int count = 0;

void* pthread_run()
{
    int i = 0;
    int ret = 0;
    while(i &lt; 5000)
    {
        i++;
        ret = count;
        printf("process ID:%d,pthread ID:%lu,count:%d\n",getpid(),pthread_self(),count);
        count = ret + 1;
    }
}

int main()
{
    int ret = 0;
    pthread_t id1;
    pthread_t id2;
    pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);
    pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);
    pthread_join(id1,NULL);  //wait
    pthread_join(id2,NULL);
    printf("count: %d\n",count);
    return 0;
}</pre>
<p><br></p>
<p><img src="https://img-blog.csdn.net/20170605124437896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1JOR1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
<p><br></p>
<p></p>
<div><span style="font-size:18px;">原本count全局变量+1，加5000次，但是两个线程理应加到10000才正确，但是因为count不是原子性，导致出错；</span></div>
<div style="margin:0px 0px 1.1em;">
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">我们要清楚一个增量操作分为三步骤：&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">1)从内存当中读入寄存器&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">2)寄存器进行增量操作&nbsp;</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">3)写回内存</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">正因为这三步操作，所以当不同步的时候，第一个线程已经对增量操作了，但是第二个线程读取到的依然是第一个线程增量操作之前的内容。这样就会出现问题，本来应该由1增加到3的，结果变为了由1到2。</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-size:18px;">要想代码按照我们预期的想法加到10000，必须加互斥锁，保护临界资源：修改上代码如下：</span></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"></span></span><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><b>[cpp]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 237px; top: 2264px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 237px; top: 2264px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-cpp"><li class="alt"><span><span class="preprocessor">#include&lt;stdio.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;pthread.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;string.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="preprocessor">#include&lt;sys/types.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="preprocessor">#include&lt;unistd.h&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>pthread_mutex_t&nbsp;lock&nbsp;=&nbsp;PTHREAD_MUTEX_INITIALIZER;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">void</span><span>*&nbsp;pthread_run()&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;5000)&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;lock);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"process&nbsp;ID:%d,pthread&nbsp;ID:%lu,count:%d\n"</span><span>,getpid(),pthread_self(),count);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;ret&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;lock);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;sleep(200);</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//return&nbsp;(void*)5;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes">int</span><span>&nbsp;ret&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id1;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;id2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id1,NULL);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(id2,NULL);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span class="string">"count:&nbsp;%d\n"</span><span>,count);&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" name="code" style="display: none;">#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
int count = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* pthread_run()
{
    int i = 0;
    int ret = 0;
    while(i &lt; 5000)
    {
        pthread_mutex_lock(&amp;lock);
        i++;
        ret = count;
        printf("process ID:%d,pthread ID:%lu,count:%d\n",getpid(),pthread_self(),count);
        count = ret + 1;
        pthread_mutex_unlock(&amp;lock);
    }
    // sleep(200);
    //return (void*)5;
}

int main()
{
    int ret = 0;
    pthread_t id1;
    pthread_t id2;
    pthread_create(&amp;id1,NULL,&amp;pthread_run,NULL);
    pthread_create(&amp;id2,NULL,&amp;pthread_run,NULL);
    pthread_join(id1,NULL);  
    pthread_join(id2,NULL);
    printf("count: %d\n",count);
    return 0;
}
</pre>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><span style="font-family:'microsoft yahei';"><span style="color:rgb(51,51,51);">添加互斥锁保证其原子性，结果正确：</span></span><br></span></span></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><br></span></span></div>
<img src="https://img-blog.csdn.net/20170605134804311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1JOR1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"></span></span>
<div style="margin:0px 0px 1.1em;">
<div><span style="font-size:32px;">死锁：</span></div>
<div>1、什么是死锁：</div>
<div align="left" style="min-height:16pt;">
<div><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，如果同一个线程先后两次调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，在第二次调用时，由于锁已经被占用，该线程会</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">就永远处于挂起等待状态了，这叫做死锁（</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">Deadlock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">）。</span></span></div>
<div><span style="font-size:12pt;"><span style="font-family:'AdobeSongStd-Light';"><span style="color:rgb(1,1,1);">&nbsp; &nbsp; &nbsp;另一种：若</span></span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">获</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">得了锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">获得了锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，这时线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">试图获得锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，结果是需要挂起等待线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">释放</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">2</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，而这时线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">也调用</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">lock</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">试图获得锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，结果是需要挂起等待线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">释放锁</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">1</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">，于是线程</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">A</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">和</span></span><span style="font-family:ArialMT;color:#010101;"><span style="font-size:12pt;">B</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">都</span></span><span style="font-family:'AdobeSongStd-Light';color:#010101;"><span style="font-size:12pt;">永远处于挂起状态了。</span></span></div>
</div>
<div><span style="font-size:18px;">2、死锁产生的四个必要条件：</span></div>
<div><span style="color:rgb(111,111,111);font-family:Arial;"><span style="font-size:18px;">（1）&nbsp;互斥条件：一个资源每次只能被一个进程使用</span></span></div>
<div><span style="font-size:18px;"><span style="color:rgb(111,111,111);font-family:Arial;">（2）&nbsp;请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br style="color:rgb(111,111,111);font-family:Arial;"><span style="color:rgb(111,111,111);font-family:Arial;">（3）&nbsp;不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br style="color:rgb(111,111,111);font-family:Arial;"><span style="color:rgb(111,111,111);font-family:Arial;">（4）&nbsp;循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span></span></div>
<div><span style="font-size:18px;"><span style="color:rgb(111,111,111);font-family:Arial;">这四个条件是</span><span style="font-family:Arial;background-color:rgb(255,255,102);">死锁的必要条件</span><span style="color:rgb(111,111,111);font-family:Arial;">，只要系统发生死锁，这些条件必然成立，而只要上述条件之</span><span style="color:rgb(111,111,111);font-family:Arial;">一不满足，就不会发生死锁。</span></span></div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;">3、如何避免死锁：</span></span></span></div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;"><br></span></span></span></div>
<div>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">预防死锁：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">资源一次性分配：（破坏请求和保持条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">避免死锁:</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库" style="color:rgb(223,52,52);font-weight:bold;" target="_blank">算法</a>是银行家算法。</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">检测死锁</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">首先为每个进程和每个资源指定一个唯一的号码；</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">然后建立资源分配表和进程等待表，例如：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">解除死锁:</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</span></p>
<p style="margin-top:0px;margin-bottom:1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</span></p>
<div style="margin:0px 0px 1.1em;color:rgb(51,51,51);font-family:'microsoft yahei';">
<span style="font-size:18px;">撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</span></div>
</div>
<div><span style="font-family:Arial;"><span style="color:rgb(111,111,111);"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></span></span></span></div>
<div><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
<div><span style="font-size:32px;"><br></span></div>
</div>
<br></div>
<div><span style="color:rgb(51,51,51);"><span style="font-family:'microsoft yahei';"><br></span></span></div>
</div>
<br><p></p>