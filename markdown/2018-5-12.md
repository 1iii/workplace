5/11/2018 9:04:50 AM 
# C++学习笔记-01#
##静态成员与静态函数 ##
### 1、静态成员的特点 ###

（1）static数据成员在类的内部声明，但只能在类的外部定义，在类的外部不能指定static，在类的定义时候进行初始化；

（2）static数据成员只能在类的外部进行初始化（特例：当整型const static数据成员被常量表达式初始化时，就可以在类的内部进行初始化，但还需要在外部进行定义）；

（3） static数据成员可以是该成员所属的类类型，而非static数据成员只能自身类的引用或者指针；

（4）static数据成员可以用作类成员函数的默认实参；

（5）static数据成员的值可以改变；
###2、静态成员和非静态成员的区别 ###
（1） 静态变量使用 static 修饰符进行声明，在类被实例化时创建，通过类和对象都可以进行访问；

（2）不带有 static 修饰符声明的变量称做非静态变量，在对象被实例化时创建，通过对象访问；

（3） 一个类的所有实例的同一静态变量都是同一个值，同一个类的不同实例的同一非静态变量可以是不同的值；

（4） 静态函数的实现里不能使用非静态成员，如非静态变量、非静态函数等；
### 3、静态成员函数的特点 ###
（1） static 成员函数没有 this 形参，它可以访问所属类的 static 成员，但不能访问非 static 成员；

（2）static成员函数既可以在类的内部定义，也可以在类的外部定义，在外部定义时，不能重复指定static保留字；

（3）static成员函数不能声明为虚函数，不能实现动态绑定；

（4）static 成员函数不能声明为const，因为const是针对this是不是const而言的；

（5）构造函数、析构函数不能为静态函数；
#野指针#
## 造成野指针的原因 ##
      1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。
      2、指针P被FREE或者DELETE之后，没有置为NULL，让人误以为P是个合法的指针。
      3、指针操作超越了变量的作用范围。这种情况让人防不胜防。
##避免出现野指针的一些方法##
（1） 声明指针时要进行初始化;

     int *p = NULL;

（2） 指针删除时要用对操作符；

	对于new 出来的单个指针，用delete进行释放
	对于new 出来的指针数组，如int[]，要用delete []进行释放
	mallocc 出来的指针用free释放
	注：关于delete和delete []的详细使用介绍，请参考Effective C++条款16

（3）释放指针后要给指针NULL地址

	delete [] pointer;
	pointer = NULL;

（4）可以在分配完内存以后使用ASSERT进行检验
	int *p = 5;
	ASSERT(int != NULL);
	如果这样写的话，一旦条件判断不成立则程序会终止运行。主动终止程序总比运行时被迫崩溃的好，至少方便找出Bug的位置^_^。
[ASSERT的详细介绍](https://www.cnblogs.com/daochong/p/6571849.html)

#字节对齐#
##重要概念##
	1.基本数据类型自身的对齐值：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
	2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。
	3.指定的对齐值：#pragma pack (value)时的指定对齐值value。
	4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。
##win32平台下编译器的对齐策略##
（1）结构体变量的首地址是其有效对齐值的整数倍；

	注：编译器在给结构体开辟空间时，首先计算结构体的有效对齐值，然后寻找是其有效对齐值整数倍的内存地址，作为结构体的首地址。
（2）结构体的每个成员相对于结构体首地址的偏移量是成员的有效对齐值的整数倍；

	注：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的有效对齐值得整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。
（3）结构体的总大小为结构体的有效对齐值的整数倍（如有需要，编译器会在最末一个成员之后加上填充字节）；

注：在设计结构体的时候，把占用空间小的类型排在前面，占用空间大的类型排在后面，这样可以相对节约一些对齐空间。